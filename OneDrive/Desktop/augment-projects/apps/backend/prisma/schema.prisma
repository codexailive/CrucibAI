generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(cuid())
  encrypted_email   String   @unique
  email             String   @unique
  name              String
  encrypted_password String
  passwordHash      String
  password          String   // Added for auth routes
  role              String?  // Added for GDPR service
  lastLoginAt       DateTime? // Added for GDPR service
  preferences       Json?    // Added for GDPR service
  encryptionSettings Json?   // Added for GDPR service
  stripeCustomerId  String?
  mfaEnabled        Boolean  @default(false)
  mfaSecret         String?
  lastActiveAt      DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  subscription      UserSubscription?
  deploymentPurchases DeploymentPurchase[]
  activeDeployments ActiveDeployment[]
  overageCharges    OverageCharge[]
  usageAlerts       UsageAlert[]
  supportTickets    SupportTicket[]
  ticketReplies     TicketReply[]
  usageTracking     UsageTracking[]
  dataConsents      DataConsent[]
  pluginExecutions  PluginExecution[]
  accountCredits    AccountCredit[]
  invoices          Invoice[]
  payments          Payment[]
  quantumJobs       QuantumJob[]
  arvrSessions      ARVRSession[]
  auditLogs         AuditLog[]
  apiRequests       ApiRequest[]
  marketplaceInstallations MarketplaceInstallation[]
}

model DeploymentPurchase {
  id        String   @id @default(cuid())
  userId    String
  tier      String   // Starter, Professional, etc.
  quantity  Int      // Number of deployments
  price     Float    // Total paid
  status    String   // active, expired
  purchasedAt DateTime @default(now())
  expiresAt DateTime

  user User @relation(fields: [userId], references: [id])
}

model ActiveDeployment {
  id        String   @id @default(cuid())
  userId    String
  purchaseId String
  name      String
  platform  String   // Vercel, AWS, etc.
  status    String   // deploying, active, failed
  url       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model OverageCharge {
  id        String   @id @default(cuid())
  userId    String
  type      String   // ai_calls, quantum, storage, etc.
  amount    Float    // Charge amount
  units     Int      // Units over limit
  rate      Float    // Per-unit rate
  billedAt  DateTime @default(now())
  status    String   // pending, paid, failed

  user User @relation(fields: [userId], references: [id])
}

model UsageAlert {
  id        String   @id @default(cuid())
  userId    String
  type      String   // ai_calls, quantum, etc.
  threshold Float    // 0.8 = 80% of limit
  message   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

model SupportTicket {
  id          String   @id @default(cuid())
  userId      String
  subject     String
  message     String
  status      String   // open, in_progress, resolved, closed
  priority    String   // low, medium, high, urgent
  category    String   // billing, technical, feature
  assignedTo  String?  // Agent ID
  closedAt    DateTime?
  closedBy    String?  // user, support
  satisfactionRating Int? // 1-5 rating
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
  replies TicketReply[]

  @@map("support_tickets")
}

model TicketReply {
  id        String   @id @default(cuid())
  ticketId  String
  userId    String
  message   String
  isInternal Boolean  @default(false)
  createdAt DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticketId], references: [id])
  user User @relation(fields: [userId], references: [id])
}

model KnowledgeBaseArticle {
  id        String   @id @default(cuid())
  title     String
  content   String   // Markdown
  category  String
  tags      String
  published Boolean  @default(true)
  views     Int      @default(0)
  helpful   Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Subscription {
  id          String   @id @default(cuid())
  name        String   // Discovery, Starter, Professional, etc.
  tier        String   @unique
  amount      Float    // Monthly price
  features    Json     // List of features
  isActive    Boolean  @default(true)
  stripePriceId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("subscriptions")
}

model UserSubscription {
  id                    String   @id @default(cuid())
  userId                String   @unique
  tier                  String   // Discovery, Starter, Professional, Business, Team, Enterprise, Unlimited
  status                String   // active, cancelled, payment_failed
  billingCycle          String   @default("monthly") // monthly, annual
  nextBillingDate       DateTime
  currentPeriodStart    DateTime?
  currentPeriodEnd      DateTime?
  annualDiscount        Float    @default(0.167) // 16.7% discount
  autoRenew             Boolean  @default(true)
  renewalReminderSent   Boolean  @default(false)
  stripeSubscriptionId  String?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id])
  payments Payment[]
}

model UsageTracking {
  id        String   @id @default(cuid())
  userId    String
  month     String   // YYYY-MM format
  service   String   // service type
  provider  String?  // openai, anthropic, google, etc.
  type      String?  // text, image, audio
  amount    Float    // Number of units used
  cost      Float    @default(0) // Cost in USD
  timestamp DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, month])
  @@map("usage_tracking")
}

model AuditLogEntry {
  id        String   @id @default(cuid())
  eventId   String   @unique
  action    String
  userId    String
  data      String?  // JSON data
  createdAt DateTime @default(now())
}

model EncryptionSettings {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false)
  algorithm  String?
  keyId      String?
  rotatedAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
}

model ServiceConfig {
  id                   String   @id @default(cuid())
  name                 String   @unique
  auditLoggingEnabled  Boolean  @default(false)
  config               String?  // JSON config
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

model ComplianceEvidence {
  id        String   @id @default(cuid())
  type      String   // automated, manual
  standard  String   // SOC2, GDPR, etc.
  control   String
  evidence  String   // JSON evidence data
  createdAt DateTime @default(now())
}

model Attestation {
  id        String   @id @default(cuid())
  type      String
  subject   String
  issuer    String
  issuedAt  DateTime @default(now())
  expiresAt DateTime?
  data      String?  // JSON attestation data
}

model Documentation {
  id        String   @id @default(cuid())
  title     String
  type      String   // compliance, technical, etc.
  content   String?  // Markdown or JSON content
  url       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model QuantumJob {
  id          String    @id @default(cuid())
  userId      String
  graphId     String
  type        String    // qaoa_optimization, vqe, etc.
  status      String    // running, completed, failed
  priority    String    // low, medium, high
  backend     String    // braket, qiskit, etc.
  result      String?   // JSON result
  error       String?
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?

  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id        String   @id @default(cuid())
  eventId   String   @unique
  action    String
  userId    String
  data      String?  // JSON data
  createdAt DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ARVRSession {
  id        String   @id @default(cuid())
  userId    String
  type      String   // AR, VR
  sceneData String?  // JSON scene data
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model MarketplaceInstallation {
  id          String   @id @default(cuid())
  userId      String
  packageId   String
  packageName String
  version     String
  status      String   // installed, active, disabled
  installedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  plugin MarketplacePlugin? @relation(fields: [packageId], references: [id])

  @@map("marketplace_installations")
}

model MarketplacePlugin {
  id          String   @id @default(cuid())
  name        String
  description String?
  category    String
  version     String
  author      String
  price       Float    @default(0)
  rating      Float    @default(0)
  downloads   Int      @default(0)
  status      String   @default("approved") // approved, pending, rejected
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  installations MarketplaceInstallation[]

  @@map("marketplace_plugins")
}

model QuantumCircuit {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?
  circuitData String   // JSON circuit definition
  gates       String   // JSON gates array
  qubits      Int
  depth       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model DataConsent {
  id           String   @id @default(cuid())
  userId       String
  consentType  String
  consentGiven Boolean
  ipAddress    String?
  timestamp    DateTime @default(now())

  user         User     @relation(fields: [userId], references: [id])
}

model DataBreach {
  id              String   @id @default(cuid())
  description     String
  affectedUsers   String[]
  dataTypes       String[]
  severity        String
  discoveredAt    DateTime @default(now())
  resolvedAt      DateTime?
  mitigationSteps String[]
  createdAt       DateTime @default(now())
}

model PluginExecution {
  id        String   @id @default(cuid())
  userId    String
  pluginId  String
  method    String
  params    String
  result    String?
  timestamp DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
}

model AccountCredit {
  id        String   @id @default(cuid())
  userId    String
  amount    Float
  reason    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
}

model Invoice {
  id                 String   @id @default(cuid())
  userId             String
  periodStart        DateTime
  periodEnd          DateTime
  subscriptionAmount Float
  overageAmount      Float
  paymentsAmount     Float
  totalDue           Float
  status             String
  stripeInvoiceId    String?
  createdAt          DateTime @default(now())

  user               User     @relation(fields: [userId], references: [id])
}

model Payment {
  id                String   @id @default(cuid())
  userId            String
  subscriptionId    String?
  amount            Float
  status            String
  type              String   // subscription, one_time
  stripeChargeId    String?
  stripeRefundId    String?
  refundedAmount    Float?
  refundReason      String?
  refundedAt        DateTime?
  chargebackReason  String?
  chargebackAmount  Float?
  chargebackDate    DateTime?
  createdAt         DateTime @default(now())

  user              User     @relation(fields: [userId], references: [id])
  userSubscription  UserSubscription? @relation(fields: [subscriptionId], references: [id])
}

model ApiRequest {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String
  method    String
  timestamp DateTime @default(now())
  ipAddress String

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("api_requests")
}


